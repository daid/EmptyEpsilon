<!DOCTYPE html>
<html lang="us">

    <head>
        <script src="jquery.min.js"></script>
        <style>
            /* Generated by Font Squirrel (http://www.fontsquirrel.com) on March 23, 2016 */
            @font-face {
                font-family: 'bebas_neue_regularregular';
                src: url('../www/fonts/bebasneue_regular-webfont.eot');
                src: url('../www/fonts/bebasneue_regular-webfont.eot?#iefix') format('embedded-opentype'),
                     url('../www/fonts/bebasneue_regular-webfont.woff2') format('woff2'),
                     url('../www/fonts/bebasneue_regular-webfont.woff') format('woff'),
                     url('../www/fonts/bebasneue_regular-webfont.ttf') format('truetype'),
                     url('../www/fonts/bebasneue_regular-webfont.svg#bebas_neue_regularregular') format('svg');
                font-weight: normal;
                font-style: normal;
            }
        </style>
        <style>
            body {
                font-family: 'bebas_neue_regularregular', 'Impact', 'Arial Narrow', sans-serif;
                background-color: #000;
                user-select: none;
                -moz-user-select: none;
                -webkit-user-select: none;
                -ms-user-select: none;
            }

            canvas {
                position: absolute;
                top: 0;
                left: 0;
                margin: 0;
                width: 100%;
                height: 100%;
                cursor: move;
            }

            #controls {
                position: absolute;
                bottom: 20px;
                left: 0;
                right: 0;
                margin: auto;
                width: 100%;
                height: 40px;
                text-align: center;
            }
            #zoom_selector {
                position: absolute;
                top: 40px;
                right: -20px;
                width: 100px;
                transform: rotate(270deg);
            }

            .ee-button {
              font-family: 'bebas_neue_regularregular', 'Impact', 'Arial Narrow', sans-serif;
              font-size: 24px;
              padding: 4px 20px;
              border-radius: 34px;
              background: rgba(0,0,0,0.8);
              color: #fff;
              transition: all 0.2s;
              position: relative;

              min-height: 40px;
              box-sizing: border-box;
              border: 2px solid rgba(255,255,255,0.5);
              cursor: pointer;
              display: inline;
              z-index: 1;
              user-select: none;
              -moz-user-select: none;
              -webkit-user-select: none;
              -ms-user-select: none;
            }
            .ee-button-active {
                color: #000;
                background-color: rgba(0,0,0,0);
            }
            .ee-button-active::after {
                content: "";
                color: #000;
                text-align: center;
                padding-top: 2px;
                display: block;
                background: #fff;
                position: absolute;
                width: auto;
                height: auto;
                top: 2px;
                right: 2px;
                left: 2px;
                bottom: 2px;
                border-radius: 20px;
                border-color: rgba(255,255,255,1);
                z-index: -1;
            }
            .ee-button:focus {
                outline: none;
            }

            input[type=range] {
              width: 400px;
              height: 40px;
              display: inline;
              position: relative;
              top: 11px;
              background: none;
              -webkit-appearance: none;
              margin: 0;
              box-sizing: border-box;
              padding: 0;
              border: 0;
            }
            input[type=range]:focus {
              outline: none;
              border-color: rgba(255,255,255,1);
            }
            input[type=range]::-webkit-slider-runnable-track {
              width: 100%;
              height: 40px;
              cursor: pointer;
              background: rgba(0, 0, 0, 0.8);
              border-radius: 34px;
              border: 2px solid #fff;
            }
            input[type=range]::-webkit-slider-thumb {
              border: 3px solid #000;
              height: 34px;
              width: 34px;
              border-radius: 34px;
              background: #fff;
              cursor: pointer;
              -webkit-appearance: none;
              margin-top: 1px;
            }
            input[type=range]:focus::-webkit-slider-runnable-track {
              background: rgba(28, 28, 28, 0.8);
            }
            input[type=range]::-moz-range-track {
              width: 100%;
              height: 40px;
              cursor: pointer;
              background: rgba(0, 0, 0, 0.8);
              border-radius: 34px;
              border: 2px solid rgba(255,255,255,0.5);
            }
            input[type=range]::-moz-range-thumb {
              border: 3px solid #000;
              height: 34px;
              width: 34px;
              border-radius: 34px;
              background: #fff;
              cursor: pointer;
            }
            input[type=range]::-ms-track {
              width: 100%;
              height: 30px;
              cursor: pointer;
              background: transparent;
              border-color: transparent;
              color: transparent;
            }
            input[type=range]::-ms-fill-lower {
              background: rgba(0, 0, 0, 0.8);
              border: 2px solid rgba(255,255,255,0.5);
              border-radius: 34px;
            }
            input[type=range]::-ms-fill-upper {
              background: rgba(0, 0, 0, 0.8);
              border: 2px solid rgba(255,255,255,0.5);
              border-radius: 34px;
            }
            input[type=range]::-ms-thumb {
              border: 3px solid #000;
              width: 34px;
              border-radius: 34px;
              background: #fff;
              cursor: pointer;
              height: 34px;
            }
            input[type=range]:focus::-ms-fill-lower {
              background: rgba(0, 0, 0, 0.8);
            }
            input[type=range]:focus::-ms-fill-upper {
              background: rgba(28, 28, 28, 0.8);
            }

            #dropzone {
                position: absolute;
                top: 0;
                bottom: 0;
                left: 0;
                right: 0;
                margin: auto;
                vertical-align: middle;
                line-height: 4;
                width: 400px;
                height: 160px;
                background-color: #808098;
                border: 2px solid rgba(255,255,255,1);
                border-radius: 34px;
                box-sizing: border-box;
                text-align: center;
                font-size: 40px;
                color: #fff;
                user-select: none;
                -moz-user-select: none;
                -webkit-user-select: none;
                -ms-user-select: none;
                cursor: default;
            }
        </style>
    </head>

    <body>
        <canvas id="canvas" width="200" height="100" unselectable></canvas>
        <div id="controls" unselectable>
            <button class="ee-button" id="autoplay" unselectable>Play</button>
            <input id="time_selector" type="range" min="0" max="0" value="0">
            <button class="ee-button" id="callsigns" unselectable>Callsigns</button>
        </div>
        <input id="zoom_selector" type="range" min="2" max="150"> <!-- smaller range than mouse wheel -->
        <div id="dropzone" unselectable>
            <p style="margin: 0;">Drop log file here</p>
            <input id="filepicker" type="file">
        </div>
        <script>
            class LogData
            {
                constructor(text)
                {
                    this.entries = [];

                    var lines = text.match(/^.*([\n\r]+|$)/gm);
                    for (var index = 0; index < lines.length; index++)
                    {
                        try
                        {
                            if (lines[index].trim() != "")
                                this.entries.push(JSON.parse(lines[index]));
                        }catch(err){
                            console.debug("Read json line error: ", err);
                        }
                    }
                    console.debug("Loaded: " + this.entries.length + " log entries")
                }

                getMaxTime()
                {
                    return this.entries[this.entries.length-1].time;
                }

                getEntriesAtTime(time)
                {
                    var last_objects = {}
                    var static_objects = {}
                    for (var index = 0; index < this.entries.length; index++)
                    {
                        var entry = this.entries[index];
                        if (entry.time > time)
                            break
                        last_objects = entry.objects;
                        for(var i=0; i<entry.new_static.length; i++)
                        {
                            var obj = entry.new_static[i];
                            static_objects[obj.id] = obj;
                        }
                        for(var i=0; i<entry.del_static.length; i++)
                        {
                            var obj_id = entry.del_static[i];
                            delete static_objects[obj_id];
                        }
                    }
                    for(var i=0; i<last_objects.length; i++)
                    {
                        var obj = last_objects[i];
                        static_objects[obj.id] = obj;
                    }
                    return static_objects;
                }
            };

            class Canvas
            {
                constructor()
                {
                    this._canvas = $("#canvas");
                    this._canvas.mousedown(function(e) { canvas._mouseDown(e); });
                    this._canvas.mousemove(function(e) { canvas._mouseMove(e); });
                    this._canvas.mouseup(function(e) { canvas._mouseUp(e); });
                    this._canvas.bind('mousewheel', function(e) { e.stopPropagation(); e.preventDefault(); canvas._mouseWheel(e.originalEvent.wheelDelta); });
                    $(window).resize(function(e) { canvas.update(); });

                    this._view_x = 0;
                    this._view_y = 0;
                    this._zoom_scale = 100.0 / 20000.0; // 20U = 100 pixels at default zoom.
                    this.showCallsigns = false;

                    this.update()
                }

                _mouseDown(e)
                {
                    this._last_mouse_x = e.clientX
                    this._last_mouse_y = e.clientY
                }
                _mouseMove(e)
                {
                    if (!e.buttons)
                        return;

                    this._view_x += (this._last_mouse_x - e.clientX) / this._zoom_scale;
                    this._view_y += (this._last_mouse_y - e.clientY) / this._zoom_scale;

                    this._last_mouse_x = e.clientX;
                    this._last_mouse_y = e.clientY;

                    this.update();
                }
                _mouseUp(e)
                {
                    this._last_mouse_x = e.clientX
                    this._last_mouse_y = e.clientY
                }

                _mouseWheel(delta)
                {
                    // Cap delta to avoid impossible zoom scales.
                    delta = Math.max(delta, -999.99);
                    this._zoom_scale *= 1.0 + delta / 1000.0;
                    $("#zoom_selector").val(canvas._zoom_scale * 1000);
                    this.update();
                }

                update()
                {
                    var w = document.documentElement.clientWidth;
                    var h = document.documentElement.clientHeight;
                    this._canvas[0].width = w;
                    this._canvas[0].height = h;

                    // Warkaround for weird intermittent canvas bug.
                    if (isNaN(this._view_x))
                    {
                        console.error("x was undef: ", this._view_x);
                        this._view_x = 0;
                    }
                    if (isNaN(this._view_y))
                    {
                        console.error("y was undef: ", this._view_y);
                        this._view_y = 0;
                    }

                    // Cap the zoom scales to reasonable levels.
                    if (this._zoom_scale > 1.25) // 100px = 0.08U
                        this._zoom_scale = 1.25;
                    else if (this._zoom_scale < 0.001) // 100px = 100U
                        this._zoom_scale = 0.001;

                    // Draw the canvas background.
                    var ctx = this._canvas[0].getContext("2d");
                    ctx.fillStyle = "#000";
                    ctx.fillRect(0, 0, w, h);

                    // Don't bother if we don't have a log to read.
                    if (!log)
                        return

                    // Set the scenario time to the time selector range input.
                    var time = $("#time_selector").val();

                    // Draw the background grid.
                    this.drawGrid(ctx, this._view_x, this._view_y, w, h, 20000.0, "#202040");

                    // For each entry at the given time, determine its type and
                    // draw an appropriate shape.
                    var entries = log.getEntriesAtTime(time);
                    for(var id in entries)
                    {
                        var entry = entries[id];
                        var x = (entry["position"][0] - this._view_x) * this._zoom_scale + w / 2.0;
                        var y = (entry["position"][1] - this._view_y) * this._zoom_scale + h / 2.0;

                        if (entry.type == "Nebula")
                        {
                            this.drawCircle(ctx, x, y, this._zoom_scale, "#202080", 0.3, 300)
                        }
                        else if (entry.type == "BlackHole")
                        {
                            this.drawCircle(ctx, x, y, this._zoom_scale, "#802020", 0.3, 300)
                        }
                        else if (entry.type == "WormHole")
                        {
                            this.drawCircle(ctx, x, y, this._zoom_scale, "#800080", 0.3, 300)
                        }
                        else if (entry.type == "Mine")
                        {
                            // Draw mine radius.
                            this.drawCircle(ctx, x, y, this._zoom_scale, "#808080", 0.3, 30)

                            // Draw mine location.
                            this.drawCircle(ctx, x, y, this._zoom_scale, "#FFF", 1.0, 1)
                        }
                        else if (entry.type == "PlayerSpaceship")
                        {
                            this.drawShip(ctx, x, y, entry);
                        }
                        else if (entry.type == "CpuShip")
                        {
                            this.drawShip(ctx, x, y, entry);
                        }
                        else if (entry.type == "WarpJammer")
                        {
                            this.drawCircle(ctx, x, y, this._zoom_scale, "#C89664", 1.0, 4)
                        }
                        else if (entry.type == "SupplyDrop")
                        {
                            this.drawCircle(ctx, x, y, this._zoom_scale, "#0FF", 1.0, 2);
                        }
                        else if (entry.type == "SpaceStation")
                        {
                            this.drawStation(ctx, x, y, entry);
                        }
                        else if (entry.type == "Asteroid")
                        {
                            this.drawCircle(ctx, x, y, this._zoom_scale, "#FFC864", 1.0, 1)
                        }
                        else if (entry.type == "ScanProbe")
                        {
                            // Draw probe scan radius.
                            this.drawCircle(ctx, x, y, this._zoom_scale, "#60C080", 0.1, 300)

                            // Draw probe location.
                            this.drawCircle(ctx, x, y, this._zoom_scale, "#60C080", 1.0, 1)
                        }
                        else if (entry.type == "Nuke")
                        {
                            this.drawSquare(ctx, x, y, this._zoom_scale, "#F40", 1.0, 1)
                        }
                        else if (entry.type == "EMPMissile")
                        {
                            this.drawSquare(ctx, x, y, this._zoom_scale, "#0FF", 1.0, 1)
                        }
                        else if (entry.type == "HomingMissile")
                        {
                            this.drawSquare(ctx, x, y, this._zoom_scale, "#FA0", 1.0, 1)
                        }
                        else if (entry.type == "HVLI")
                        {
                            this.drawSquare(ctx, x, y, this._zoom_scale, "#AAA", 1.0, 1)
                        }
                        else if (entry.type == "VisualAsteroid")
                        {
                        }
                        else if (entry.type == "BeamEffect")
                        {
                            this.drawCircle(ctx, x, y, this._zoom_scale, "#A60", 0.5, 2)
                        }
                        else if (entry.type == "ExplosionEffect")
                        {
                            this.drawCircle(ctx, x, y, this._zoom_scale, "#FF0", 0.5, 3)
                        }
                        else if (entry.type == "ElectricExplosionEffect")
                        {
                            this.drawCircle(ctx, x, y, this._zoom_scale, "#0FF", 0.5, 3)
                        }
                        else
                        {
                            console.debug("Unknown object type: ", entry.type)
                            this.drawSquare(ctx, x, y, this._zoom_scale, "#F00", 1.0, 2)
                        }
                    }

                    // Draw the info line showing the scenario time, scale,
                    // X/Y coordinates, and sector designation.
                    ctx.fillStyle = "#FFF";
                    var stateTextTime = formatTime(time);
                    var stateTextZoom = "100px = " + (0.1 / this._zoom_scale).toPrecision(3) + "U";
                    var stateTextX = "X: " + this._view_x.toPrecision(6);
                    var stateTextY = "Y: " + this._view_y.toPrecision(6);
                    var stateTextSector = "(" + this.getSectorDesignation(this._view_x, this._view_y) + ")";
                    // TODO: Fix out-of-range sector designations in-game.
                    var stateText = stateTextTime + " / " + stateTextZoom + " / " + stateTextX + " / " + stateTextY + " " + stateTextSector;
                    ctx.font = "20px bebas_neue_regularregular, Impact, Arial, sans-serif";
                    ctx.fillText(stateText, 20, 40);
                }

                getSectorDesignation(x, y)
                {
                    // Sectors are designated with a letter (Y axis) and number
                    // (X axis). Coordinates 0, 0 represent the intersection of
                    // F and 5. Each sector is a 20U (20000) square.

                    // TODO: Fix out-of-range sector designations in-game.
                    var sectorLetter = String.fromCharCode('F'.charCodeAt() + Math.floor(y / 20000));

                    // Sector numbers are 0-99.
                    var sectorNumber = 5 + Math.floor(x / 20000);
                    if (sectorNumber < 0)
                        sectorNumber = 100 + sectorNumber;

                    return sectorLetter + sectorNumber;
                }

                drawGrid(ctx, x, y, canvasWidth, canvasHeight, gridIntervalSize, gridlineColor)
                {
                    ctx.lineWidth = 0.5;
                    ctx.strokeStyle = gridlineColor;

                    var gridlineHoriz;
                    var gridlineVert;

                    // Translate the visible canvas into world coordinates.
                    var canvasEdges = {
                        "left":   x - ((canvasWidth / 2) / this._zoom_scale),
                        "right":  x + ((canvasWidth / 2) / this._zoom_scale),
                        "top":    y - ((canvasHeight / 2) / this._zoom_scale),
                        "bottom": y + ((canvasHeight / 2) / this._zoom_scale)
                    };

                    // Find the first gridlines from the top left.
                    var gridlineHorizTop = canvasEdges.top - canvasEdges.top % 20000;
                    var gridlineVertLeft = canvasEdges.left - canvasEdges.left % 20000;
                    var gridlineVertWorldList = [];
                    var gridlineVertCanvasList = [];
                    var gridlineHorizWorldList = [];
                    var gridlineHorizCanvasList = [];

                    // Draw horizontal gridlines until we run out of canvas.
                    for(var i = gridlineHorizTop; i <= canvasEdges.bottom; i = i + gridIntervalSize)
                    {
                        // Translate screen position to world position.
                        gridlineHoriz = (i - y) * this._zoom_scale + canvasHeight / 2.0;
                        gridlineHorizWorldList.push(i);
                        gridlineHorizCanvasList.push(gridlineHoriz);

                        ctx.beginPath();
                        ctx.moveTo(0, gridlineHoriz);
                        ctx.lineTo(canvasWidth, gridlineHoriz);
                        ctx.closePath();
                        ctx.stroke();
                    }

                    // Draw vertical gridlines until we run out of canvas.
                    for(var i = gridlineVertLeft; i < canvasEdges.right; i = i + gridIntervalSize)
                    {
                        // Translate screen position to world position.
                        gridlineVert = (i - x) * this._zoom_scale + canvasWidth / 2.0;
                        gridlineVertWorldList.push(i);
                        gridlineVertCanvasList.push(gridlineVert);

                        ctx.beginPath();
                        ctx.moveTo(gridlineVert, 0);
                        ctx.lineTo(gridlineVert, canvasHeight);
                        ctx.closePath();
                        ctx.stroke();
                    }

                    ctx.fillStyle = gridlineColor;
                    ctx.font = "24px bebas_neue_regularregular, Impact, Arial, sans-serif";
                    if (gridlineHorizCanvasList.length <= 25 && gridlineVertCanvasList.length <= 25)
                    {
                        for(var i = 0; i < gridlineHorizCanvasList.length; i++)
                        {
                            for(var j = 0; j < gridlineVertCanvasList.length; j++)
                            {
                                ctx.fillText(this.getSectorDesignation(gridlineHorizWorldList[i], gridlineVertWorldList[j]), gridlineVertCanvasList[j], gridlineHorizCanvasList[i] + 16);
                            }
                        }
                    }
                }

                getFactionColor(faction, lowColor, highColor)
                {
                    // Rudimentary faction ID; would be nice to use the GM
                    // colors from factioninfo.lua. Returns a fillStyle string.
                    if (faction == "Human Navy")
                        return "#" + lowColor + highColor + lowColor;
                    else if (faction == "Independent")
                        return "#" + lowColor + lowColor + highColor;
                    else if (faction == "Arlenians")
                        return "#" + highColor + lowColor + "0";
                    else if (faction == "Exuari")
                        return "#" + highColor + "0" + lowColor;
                    else if (faction == "Ghosts")
                        return "#" + highColor + highColor + highColor;
                    else if (faction == "Ktlitans") // Very close to Human Navy
                        return "#" + lowColor + highColor + "0";
                    else // Everybody else is evil
                        return "#" + highColor + lowColor + lowColor;
                }

                drawSquare(ctx, x, y, zoomScale, fillColor, fillAlpha, sizeModifier)
                {
                    // Draw a square that scales with the zoom level.
                    ctx.globalAlpha = fillAlpha;
                    ctx.fillStyle = fillColor;

                    // Prevent small objects from disappearing when zoomed out.
                    var sizeMultiplier = sizeModifier * (100 / 3);
                    var squareSize;

                    if (sizeModifier < 50)
                        squareSize = Math.max(sizeMultiplier * zoomScale, sizeModifier);
                    else
                        squareSize = sizeMultiplier * zoomScale;

                    ctx.fillRect(x - squareSize / 2, y - squareSize / 2, squareSize, squareSize);
                    ctx.globalAlpha = 1.0;
                }

                drawCircle(ctx, x, y, zoomScale, fillColor, fillAlpha, sizeModifier)
                {
                    // Draw a circle that scales with the zoom level.
                    ctx.globalAlpha = fillAlpha;
                    ctx.fillStyle = fillColor;

                    // Prevent small objects from disappearing when zoomed out.
                    var sizeMultiplier = sizeModifier * (100 / 3);
                    var circleSize;

                    if (sizeModifier < 50)
                        circleSize = Math.max(sizeMultiplier * zoomScale, sizeModifier / 2);
                    else
                        circleSize = sizeMultiplier * zoomScale;

                    ctx.beginPath();
                    ctx.arc(x, y, circleSize / 2, 0, 2 * Math.PI, false);
                    ctx.fill();
                    ctx.globalAlpha = 1.0;
                }

                drawCallsign(ctx, x, y, zoomScale, entry, fontSize, lowColor, highColor, textDrift)
                {
                    // Draw the object's callsign.
                    ctx.fillStyle = this.getFactionColor(entry.faction, lowColor, highColor);
                    ctx.font = fontSize + "px bebas_neue_regularregular, Impact, Arial, sans-serif";
                    var textDriftAmount = Math.max((textDrift * 66.666) * zoomScale, textDrift);
                    ctx.fillText(entry.callsign, x + textDriftAmount, y + textDriftAmount);
                }

                drawStation(ctx, x, y, entry)
                {
                    // Get its faction color.
                    var factionColor = this.getFactionColor(entry.faction, "5", "F");

                    // Draw a circle and scale it by zoom and station type.
                    var sizeModifier;

                    if (entry.station_type == "Huge Station")
                    {
                        sizeModifier = 48;
                    } else if (entry.station_type == "Large Station") {
                        sizeModifier = 36;
                    } else if (entry.station_type == "Medium Station") {
                        sizeModifier = 28;
                    } else {
                        sizeModifier = 18;
                    }

                    this.drawCircle(ctx, x, y, this._zoom_scale, factionColor, 1.0, sizeModifier);

                    // Draw its callsign.
                    if (this.showCallsigns === true)
                        this.drawCallsign(ctx, x, y, this._zoom_scale, entry, "18", "C8", "FF", sizeModifier / Math.PI);
                }

                drawShip(ctx, x, y, entry)
                {
                    // Use a brighter color for player ships.
                    var fillStyleMagnitude = "C";
                    if (entry.type == "PlayerSpaceship")
                        fillStyleMagnitude = "F";

                    // Get its faction color.
                    var factionColor = this.getFactionColor(entry.faction, "0", fillStyleMagnitude);

                    // Draw the ship rectangle and scale it on zoom.
                    this.drawSquare(ctx, x, y, this._zoom_scale, factionColor, 1.0, 4);

                    // Draw its callsign. Draw player callsigns brighter.
                    if (this.showCallsigns === true)
                        this.drawCallsign(ctx, x, y, this._zoom_scale, entry, "18", "B8", fillStyleMagnitude, 2);

                    // Draw beam arcs if the object has them.
                    if (typeof entry.config !== "undefined" && typeof entry.config.beams != "undefined")
                    {
                        for(var idx=0; idx<entry.config.beams.length; idx++)
                        {
                            var beam = entry.config.beams[idx];
                            var a = entry.rotation + beam.direction;
                            var r = beam.range * this._zoom_scale;
                            var a1 = (a - beam.arc / 2.0) / 180.0 * Math.PI
                            var a2 = (a + beam.arc / 2.0) / 180.0 * Math.PI
                            var x1 = x + Math.cos(a1) * r;
                            var y1 = y + Math.sin(a1) * r;
                            var x2 = x + Math.cos(a2) * r;
                            var y2 = y + Math.sin(a2) * r;
                            ctx.beginPath();
                            ctx.moveTo(x, y);
                            ctx.lineTo(x1, y1);
                            ctx.arc(x, y, r, a1, a2, false);
                            ctx.lineTo(x2, y2);
                            ctx.lineTo(x, y);

                            ctx.globalAlpha = 0.5
                            ctx.strokeStyle = "#F00";
                            ctx.stroke();
                            ctx.globalAlpha = 1.0
                        }
                    }
                }
            };

            // Load log data into the dropzone div and setup the time selector.
            function loadLog(data)
            {
                log = new LogData(data)
                if (log.entries.length > 0)
                {
                    $("#dropzone").hide()
                    console.debug(log.getMaxTime());
                    canvas.update();
                    $("#time_selector").attr("max", log.getMaxTime());
                }
            }

            // Format scenario time into MM:SS.
            function formatTime(time)
            {
                if (time % 60 < 10)
                    return Math.floor(time / 60) + ":0" + (time % 60)
                return Math.floor(time / 60) + ":" + (time % 60)
            }

            // Programmatically advance the time selector.
            function autoPlay(isAutoplaying)
            {
                timeValue = parseInt($("#time_selector").val());
                timeValue += 1;
                $("#time_selector").val(timeValue);
                canvas.update();
                // If we reach the end, stop autoplaying.
                if (parseInt($("#time_selector").val()) >= parseInt($("#time_selector").attr("max")))
                {
                    return !isAutoplaying;
                }
                // Otherwise, keep going.
                return isAutoplaying;
            }

            var log;
            var canvas;

            // Main function.
            $().ready(function()
            {
                // Listen from drag and drop events to load log files.
                // TODO: Add file picker option for browser/OS combos that
                // complicate drag-and-drop.
                document.addEventListener('dragover', function(e) {
                    e.stopPropagation();
                    e.preventDefault();
                    e.dataTransfer.dropEffect = 'copy';
                });
                document.addEventListener('drop', function(e) {
                    e.stopPropagation();
                    e.preventDefault();
                    var files = e.dataTransfer.files;
                    for (var i=0, file; file=files[i]; i++)
                    {
                        var reader = new FileReader();
                        reader.onload = function(e2) { loadLog(e2.target.result); }
                        reader.readAsText(file);
                    }
                });
                var filepicker = document.getElementById("filepicker");
                filepicker.addEventListener('change', function(e) {
                    e.stopPropagation();
                    e.preventDefault();
                    var file = filepicker.files[0];
                    var reader = new FileReader();
                    if (file)
                    {
                        reader.onload = function(e2) {
                            var contents = e2.target.result;
                            loadLog(contents);
                        };
                        reader.readAsText(file);
                    }
                });
                canvas = new Canvas();

                // Update the canvas when the time selector is modified.
                $("#time_selector").on("input change", function(e) {
                    canvas.update();
                });

                // Zoom bar.
                $("#zoom_selector").on("input change", function(e) {
                    var zoom_value = $("#zoom_selector").val();
                    canvas._zoom_scale = $("#zoom_selector").val() / 1000;
                    canvas.update();
                })

                // Track the play/pause button.
                var isAutoplaying = false;

                $("#autoplay").on("click", function(e) {
                    if (log != null)
                    {
                        isAutoplaying = !isAutoplaying;
                        if (isAutoplaying === true)
                        {
                            if (parseInt($("#time_selector").val()) >= parseInt($("#time_selector").attr("max")))
                                $("#time_selector").val(0);
                            $("#autoplay").addClass("ee-button-active");
                        } else {
                            $("#autoplay").removeClass("ee-button-active");
                        }
                    }
                });

                // On an interval when autoplay is enabled, increment the time controller.
                var loopAutoplay = setInterval(function() {
                    if (isAutoplaying === true)
                    {
                        isAutoplaying = autoPlay(isAutoplaying);
                    } else {
                        $("#autoplay").removeClass("ee-button-active");
                    }
                }, 100);

                // Track whether to show callsigns.
                $("#callsigns").on("click", function(e) {
                    if (log != null)
                    {
                        canvas.showCallsigns = !canvas.showCallsigns;
                        canvas.update();
                        if (canvas.showCallsigns === true)
                            $("#callsigns").addClass("ee-button-active");
                        else
                            $("#callsigns").removeClass("ee-button-active");
                    }
                });
            });
        </script>

    </body>

</html>
